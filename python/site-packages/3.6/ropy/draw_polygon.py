import sys
import json

import logging
import tkinter as tk
from robolink import (
    Robolink,
    ITEM_TYPE_ROBOT,
    ITEM_TYPE_TOOL,
    RUNMODE_SIMULATE,
    RUNMODE_MAKE_ROBOTPROG,
    ITEM_TYPE_TOOL)
from robodk import transl, rotx, roty, rotz, Mat
import ropy.logger_setup
from ropy.tk_params import IntParam, FloatParam
import importlib
import ropy.robo_utils as rutils
logger = logging.getLogger('robopy')





RDK = Robolink()
APPROACH_DIST = 150
RETRACT_DIST = 150

PI = 3.14159265359


class gui(object):
    def __init__(self):
        self._build_gui()
        self.root.mainloop()
        

    def _clear(self):
        # RDK.Spray_SetState(-1)
        # logger.debug("Clear Spray")
        RDK.Spray_SetState(0)
        RDK.Spray_Clear()

    def _initialize_spray(self):
        info, data = RDK.Spray_GetStats()
        if data.size(1) > 0:
            logger.debug("Spray gun statistics:")
            logger.debug(info)
            logger.debug(data.tr())

        tool =  RDK.Item('', ITEM_TYPE_TOOL)
        canvas = RDK.Item("x_southCanvas")
        options_command = "ELLYPSE PROJECT PARTICLE=SPHERE(4,8,1,1,0.5) STEP=8x8 RAND=2"

        close_p0 = [0, 0, -200]  # xyz in mm
        close_pA = [5, 0, -200]  # xyz in mm
        close_pB = [0, 10, -200]  # xyz in mm
        close_color = [1, 0, 0, 1]  # RGBA (0-1)

        far_p0 = [0, 0, 50]  # xyz in mm
        far_pA = [10, 0, 50]  # xyz in mm
        far_pB = [0, 20, 50]  # xyz in mm
        far_color = [0, 0, 1, 0.2]  # RGBA (0-1)

        close_param = close_p0 + close_pA + close_pB + close_color
        far_param = far_p0 + far_pA + far_pB + far_color
        volume = Mat([close_param, far_param]).tr()
        RDK.Spray_Add(tool, canvas, options_command, volume)
        # RDK.Spray_SetState(1)

    def _pose_at_vertex(self, center_pose, angle, radius):
        return center_pose * rotz(angle) * transl(radius, 0, 0) * rotz(-angle)

    def _paint_a_polygon(self):
        self.robot = RDK.Item('', ITEM_TYPE_ROBOT)
        
        RDK.setRunMode(RUNMODE_SIMULATE)
        
        radius = self.e_radius.get()
        
        vertices = self.e_vertices.get()
        
        self.speed = self.e_speed.get()
        self.angular_speed = self.speed / 10
        
        rounding = self.e_rounding.get()
        
        n = self.robot.Name()
        
        # approach = RDK.Item('a')
        center = RDK.Item('c')
        logger.debug(center.Name())

        # RDK.setRunMode(RUNMODE_MAKE_ROBOTPROG)
        # RDK.ProgramStart("paint_hexagon", "/Users/julian/projects/robot/programs", "RN_KUKA_KRC4", self.robot)
            
        self.robot.setRounding(rounding)
        center_pose = center.Pose()
        # logger.debug(center_pose)

        # approach = center_pose * transl(0, 0, -APPROACH_DIST)
        # self.robot.MoveJ(approach)

        # set up spray
        self._initialize_spray()

        seg_angle = 2 * PI / vertices
        for i in range(vertices):
            logger.debug("STROKE NUMBER: %s" % i)
            j = (i + 1) % 6
            angle_i = i * seg_angle
            angle_j = j * seg_angle

            pose_i = self._pose_at_vertex(center_pose, angle_i, radius)
            pose_j = self._pose_at_vertex(center_pose, angle_j, radius)

            if i%2 == 0:
                self._dip_brush()

            self._paint_a_stroke(pose_i, pose_j)

        # RDK.Spray_SetState(0)
        # self.robot.MoveL(approach)
        # rutils.go_canvas_approach()
        # RDK.Finish()

    def _paint_a_stroke(self, start, end):
        # logger.debug("_PAINT_A_STROKE" )
        approach = start * transl(0, 0, -APPROACH_DIST)
        # logger.debug(approach)
        # self.robot.setSpeed(self.angular_speed)
        self.robot.MoveJ(approach)
        # self.robot.setSpeed(self.speed)
        self.robot.MoveL(start)
        RDK.Spray_SetState(1)
        self.robot.MoveL(end)
        RDK.Spray_SetState(0)
        retract = end * transl(0, 0, -RETRACT_DIST)
        self.robot.MoveL(retract)


    def local_rotate_offset(self, pose, x, y=0, z=0):
        return pose * rotx(x * PI / 180.0) * \
        roty(y * PI / 180.0) * rotz(z * PI / 180.0)


    def _exercise(self):
        paint = RDK.Item('ttp_c')
        center_pose =self.robot.Pose()
        cone_angle = 10
        # pose = self.local_rotate_offset(center_pose, cone_angle, cone_angle)
        # self.robot.MoveL(pose)
        # self.robot.MoveL(center_pose)
        # pose = self.local_rotate_offset(center_pose, -cone_angle, cone_angle)
        # self.robot.MoveL(pose)
        # self.robot.MoveL(center_pose)
        # pose = self.local_rotate_offset(center_pose, -cone_angle, -cone_angle)
        # self.robot.MoveL(pose)
        # self.robot.MoveL(center_pose)
        # pose = self.local_rotate_offset(center_pose, cone_angle, -cone_angle)
        # self.robot.MoveL(pose)
        # self.robot.MoveL(center_pose)
        pose = self.local_rotate_offset(center_pose, 0, 0, 90)
        self.robot.MoveL(pose)
        self.robot.MoveL(center_pose)
        pose = self.local_rotate_offset(center_pose, 0, 0, -90)
        self.robot.MoveL(pose)
        self.robot.MoveL(center_pose)

    def _dip_brush(self):
        logger.debug("_DIP_BRUSH" )
        approach = RDK.Item('ttp_a')
        paint = RDK.Item('ttp_c')
        # self.robot.setSpeed(self.angular_speed)
        self.robot.MoveJ(approach)
        # self.robot.setSpeed(self.speed)
        self.robot.MoveL(paint)
        self._exercise()
        self.robot.MoveL(approach)

    def _build_gui(self):
        importlib.reload(ropy.tk_params)
        self.root = tk.Tk()
        self.root.title("Draw polygons")

        self.e_radius = FloatParam(
            self.root,
            label="Radius",
            value=400.0,
            min=0,
            max=1000)

        self.e_vertices = IntParam(
            self.root,
            label="Vertices",
            value=6,
            min=3,
            max=360)

        self.e_speed = FloatParam(
            self.root,
            label="Speed",
            value=100,
            min=0,
            max=1000)

        self.e_rounding = IntParam(
            self.root,
            label="Rounding",
            value=50,
            min=0,
            max=1000)

        quit_button = tk.Button(self.root,
                                text='Quit',
                                command=self.root.quit
                                )
        quit_button.grid(column=0, pady=4)
        row = int(quit_button.grid_info()["row"])
        apply_button = tk.Button(self.root,
                                 text='Apply',
                                 command=self._paint_a_polygon
                                 ).grid(row=row, column=1, pady=4)

        clear_button = tk.Button(self.root,
                                 text='Clear',
                                 command=self._clear
                                 ).grid(row=row, column=2, pady=4)
