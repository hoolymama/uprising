&ACCESS RVP

DEF RoboDKsyncLP()

INT io_id

INT j_id
INT program_id


BAS(#INITMOV,0)

PTP $AXIS_ACT

$ORI_TYPE  = #VAR
$CIRC_TYPE = #BASE
$VEL.ORI1 = 200
$VEL.ORI2 = 200
$ACC.ORI1 = 100
$ACC.ORI2 = 100

$VEL.CP=3
$ACC.CP=10

$BASE = {FRAME: X 0,Y 0,Z 0,A 0,B 0,C 0}
$TOOL = {FRAME: X 0,Y 0,Z 0,A 0,B 0,C 0}

$ADVANCE = 0
COM_ROUNDM = -1
COM_ACTION = 0
COM_ACTCNT = 0
$APO.CPTP = 0
$APO.CDIS = 0


; COM_ACTION = 0: nothing to do
; COM_ACTION = 1: nothing to do
; COM_ACTION = 2: PTP move to COM_E6AXIS
; COM_ACTION = 3: LIN move to COM_FRAME
; COM_ACTION = 4: CIRCULAR move to COM_POS, COM_FRAME
; COM_ACTION = 5: Set tool to COM_FRAME
; COM_ACTION = 6: Set speed to COM_VALUE1
; COM_ACTION = 7: Set respective [VEL.CP,  $VEL_AXIS[*], ACC.CP, ACC_AXIS[*]] to COM_VALUE1, COM_VALUE2, COM_VALUE3, COM_VALUE4
; COM_ACTION = 8: Set APO.CPTP an APO.CDIS to COM_ROUNDM, and if COM_ROUNDM >= 0, set $ADVANCE = 1
; COM_ACTION = 9: Wait for COM_VALUE1 seconds
; COM_ACTION = 10: Set digital outputs (color, shutter)
; COM_ACTION = 11: Move PTP COM_E6AXIS and LIN COM_FRAME and WAIT SEC 0 (is this home?)
    

; For case 10, the digital output channel mapping is as follows:

; CH 01 -- set dmx1 red
; CH 02 -- set dmx1 green
; CH 03 -- set dmx1 blue
; CH 04 -- set dmx1 white
; CH 05 -- set dmx2 red
; CH 06 -- set dmx2 green
; CH 07 -- set dmx2 blue
; CH 08 -- set dmx2 white
; CH 09 -- set dmx3 red
; CH 10 -- set dmx3 green
; CH 11 -- set dmx3 blue
; CH 12 -- set dmx3 white
; CH 13 -- set dmx4 red
; CH 14 -- set dmx4 green
; CH 15 -- set dmx4 blue
; CH 16 -- set dmx4 white
; CH 17 -- set dmx5 red
; CH 18 -- set dmx5 green
; CH 19 -- set dmx5 blue
; CH 20 -- set dmx5 white
; CH 21 -- set dmx6 red
; CH 22 -- set dmx6 green
; CH 23 -- set dmx6 blue
; CH 24 -- set dmx6 white
; CH 25 -- trigger dmx1 red
; CH 26 -- trigger dmx1 green
; CH 27 -- trigger dmx1 blue
; CH 28 -- trigger dmx1 white
; CH 29 -- trigger dmx2 red
; CH 30 -- trigger dmx2 green
; CH 31 -- trigger dmx2 blue
; CH 32 -- trigger dmx2 white
; CH 33 -- trigger dmx3 red
; CH 34 -- trigger dmx3 green
; CH 35 -- trigger dmx3 blue
; CH 36 -- trigger dmx3 white
; CH 37 -- trigger dmx4 red
; CH 38 -- trigger dmx4 green
; CH 39 -- trigger dmx4 blue
; CH 40 -- trigger dmx4 white
; CH 41 -- trigger dmx5 red
; CH 42 -- trigger dmx5 green
; CH 43 -- trigger dmx5 blue
; CH 44 -- trigger dmx5 white
; CH 45 -- trigger dmx6 red
; CH 46 -- trigger dmx6 green
; CH 47 -- trigger dmx6 blue
; CH 48 -- trigger dmx6 white
; CH 49-- shutter

; NOTE  Shutter [1=signal, 0=end-signal] (needs complete sequence : [1,pause,0] in order to toggle the shutter)

; This is a loop that runs forever, accepting input from RoboDK
WHILE COM_ACTION >= 0

    SWITCH COM_ACTION
    CASE 1
        ; do nothing
        COM_ACTCNT = COM_ACTCNT + 1
        COM_ACTION = 0

    CASE 2 
        IF COM_ROUNDM >= 0 THEN
            PTP COM_E6AXIS C_PTP
        ELSE
            PTP COM_E6AXIS
        ENDIF
        COM_ACTION = 0

    CASE 3
        IF COM_ROUNDM >= 0 THEN
            LIN COM_FRAME C_DIS
        ELSE
            LIN COM_FRAME
        ENDIF
        COM_ACTION = 0

    CASE 4
        IF COM_ROUNDM >= 0 THEN
            CIRC COM_POS,COM_FRAME C_DIS
        ELSE
            CIRC COM_POS,COM_FRAME
        ENDIF
        COM_ACTION = 0


    CASE 5
        COM_ACTCNT = COM_ACTCNT + 1
        $TOOL = COM_FRAME
        COM_ACTION = 0

    CASE 6
        COM_ACTCNT = COM_ACTCNT + 1
        $VEL.CP = COM_VALUE1
        COM_ACTION = 0

    CASE 7
        COM_ACTCNT = COM_ACTCNT + 1
        IF COM_VALUE1 > 0 THEN
            $VEL.CP = COM_VALUE1
        ENDIF
        IF COM_VALUE2 > 0 THEN
            ;$VEL.ORI1 = COM_VALUE2
            ;$VEL.ORI2 = COM_VALUE2
            FOR j_id=1 TO 6
                IF COM_VALUE2 > 100 THEN
                    $VEL_AXIS[j_id] = 100
                ELSE
                    $VEL_AXIS[j_id] = COM_VALUE2
                ENDIF
            ENDFOR
        ENDIF
        IF COM_VALUE3 > 0 THEN
            $ACC.CP = COM_VALUE3
        ENDIF
        IF COM_VALUE4 > 0 THEN
            ;$ACC.ORI1 = COM_VALUE4
            ;$ACC.ORI2 = COM_VALUE4
            FOR j_id=1 TO 6    
                IF COM_VALUE4 > 100 THEN
                    $ACC_AXIS[j_id] = 100
                ELSE
                    $ACC_AXIS[j_id] = COM_VALUE4
                ENDIF
            ENDFOR
        ENDIF
        COM_ACTION = 0

    CASE 8
        COM_ACTCNT = COM_ACTCNT + 1
        IF COM_ROUNDM >= 0 THEN
            IF COM_ROUNDM > 100 THEN
                $APO.CPTP = 100
            ELSE
                $APO.CPTP = COM_ROUNDM
            ENDIF
            $APO.CDIS = COM_ROUNDM
            $ADVANCE = 1
        ELSE
            $APO.CPTP = 0
            $APO.CDIS = 0
            $ADVANCE = 0
        ENDIF
        COM_ACTION = 0

    CASE 9
        COM_ACTCNT = COM_ACTCNT + 1
        WAIT SEC COM_VALUE1
        COM_ACTION = 0

    CASE 10
        COM_ACTCNT = COM_ACTCNT + 1
        ProcessDigitalOutChannel(COM_VALUE1, COM_VALUE2)
        COM_ACTION = 0
    

    CASE 11
        PTP COM_E6AXIS
        LIN COM_FRAME
        WAIT SEC 0
        COM_ACTION = 0

    ;----- DIGITAL IN ---------
    CASE 12
        COM_ACTCNT = COM_ACTCNT + 1
        io_id = COM_VALUE1
        IF COM_VALUE2 > 0.5 THEN
            WAIT FOR $IN[io_id]==TRUE
        ELSE
            WAIT FOR $IN[io_id]==FALSE
        ENDIF
        COM_ACTION = 0
    ;---------------------------

    CASE 13
        ;----- Run program COM_VALUE1 ---------
        ; (to trigger from RoboDK: use robot.RunCodeCustom("program id", INSTRUCTION_CALL_PROGRAM)
        program_id = COM_VALUE1
        SWITCH program_id
        CASE 1
        ; -- run program 1 --
        ; Drill()
        ; -------------------
        CASE 2
        ; -- run program 2 --
        ; Cut()
        ; -------------------
        ENDSWITCH

        ;--------------------------------------------
        COM_VALUE1 = 0
        COM_ACTION = 0



    ; DEFAULT
    ; COM_ACTION = 0

    ENDSWITCH


ENDWHILE

END


DEF ProcessDigitalOutChannel(chan:IN, val:IN)
    INT chan
    REAL val

    ; working variables
    INT dmx_color_id 
    INT dmx_id 
    INT color_id

    ; shutter instructions come in on channel 49
    IF chan == 49 THEN
        $OUT[1] = val > 0.5
        RETURN
    ENDIF

    ; dmx instructions come in on channels 1-48
    ; direct dmx instructions come in on channels 1-24
    ; trigger (async) instructions come in on channels 25-48
    IF chan > 24 THEN
        chan = chan - 24
        TRIGGER WHEN DISTANCE=0 DELAY=0 DO $ANOUT[chan] = val
        RETURN
    ENDIF

    $ANOUT[chan] = val

END
