import logging

from uprising import props
from uprising import robo
import datetime
import json
import pymel.core as pm
import uprising.uprising_util as uutl

import fileinput

import os

logger = logging.getLogger("uprising")


class SessionError(Exception):
    pass


class Session(object):

    @staticmethod
    def send_rack_geo():
        rack_context = pm.PyNode("RACK1_CONTEXT")
        with uutl.final_position(rack_context):
            geo = [pm.PyNode("rackTop")]
            props.send(geo)

    @staticmethod
    def send_holder_geo():
        rack_context = pm.PyNode("RACK1_CONTEXT")
        with uutl.final_position(rack_context):
            geo = pm.ls("holders|*|holderTrans|lowResGeo")
            props.send(geo)

    @staticmethod
    def send_handle_geo():
        rack_context = pm.PyNode("RACK1_CONTEXT")
        with uutl.final_position(rack_context):
            geo = pm.ls("holes|*|holeTrans|wipe_loc|handle")
            props.send(geo)

    @staticmethod
    def send_pot_geo():
        rack_context = pm.PyNode("RACK1_CONTEXT")
        with uutl.final_position(rack_context):
            geo = pm.ls("holes|*|holeTrans|dip_loc|pot")
            props.send(geo)

    @staticmethod
    def send_board_geo():
        geo = pm.PyNode("canvas")
        with uutl.final_position(geo):
            props.send(geo)

    @staticmethod
    def insert_external_dependencies(subprograms, src_fn):
        print "Writing Externals", subprograms
        func = os.path.splitext(os.path.basename(src_fn))[0]
        func = "DEF {}".format(func)
        ext_lines = ["EXT {}()".format(s) for s in subprograms]
        search = True
        for line in fileinput.FileInput(src_fn, inplace=1):
            print line,
            if search and line.startswith(func):
                search = False
                for ext in ext_lines:
                    print ext

    @staticmethod
    def save_program(directory, program_name):
        src = os.path.join(directory, "src")
        uutl.mkdir_p(src)
        src_fn = robo.write_program(src, program_name)
        logger.info("Wrote src: {}".format(program_name))
        return src_fn

    @staticmethod
    def save_station(directory, program_name):
        rdk = os.path.join(directory, "rdk")
        uutl.mkdir_p(rdk)
        rdk_fn = robo.write_station(rdk, program_name)
        logger.info("Wrote rdk: {}".format(program_name))
        return rdk_fn

    @staticmethod
    def choose_session_dir():
        export_dir = os.path.join(pm.workspace.getPath(), 'export')
        entries = pm.fileDialog2(caption="Choose directory", okCaption="Save",
                                 dialogStyle=2, fileMode=3, dir=export_dir)
        if not entries:
            pm.displayWarning('Nothing Selected')
            return

        timestamp = datetime.datetime.now().strftime('%y%m%d_%H%M')
        directory = os.path.join(directory, timestamp)
        uutl.mkdir_p(directory)
        return directory

    def orchestrate(directory, programs):
        uutl.mkdir_p(directory)
        orchestrator_file = os.path.join(directory, "src", "main.src")
        with open(orchestrator_file, 'w') as ofile:
            ofile.write("&ACCESS RVP\n")
            ofile.write("&REL 1\n")
            ofile.write("&COMMENT Generated by Uprising Robot Tools\n")
            ofile.write(
                "&PARAM TEMPLATE = C:\\KRC\Roboter\\Template\\vorgabe\n")
            ofile.write("&PARAM EDITMASK = *\n")
            ofile.write("DEF pxMain ( )\n")
            for program in programs:
                ofile.write("{}( )\n".format(program))
            ofile.write("END\n")
        print "Wrote orchestrator file: {}".format(orchestrator_file)

    @staticmethod
    def json_report(directory, name, data):
        uutl.mkdir_p(directory)
        json_file = os.path.join(directory, "{}.json".format(name))
        with open(json_file, 'w') as outfile:
            json.dump(data, outfile, indent=4)
            
    @staticmethod
    def write_maya_scene(directory, name):
        new_name = os.path.join(directory, "{}.ma".format(name) )
        orig_sn = pm.sceneName()
        pm.saveAs(new_name)
        pm.renameFile(orig_sn)

