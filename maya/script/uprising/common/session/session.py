import fileinput
import os

from uprising import props
from uprising import robo
import datetime
import json
import pymel.core as pm
import uprising.utils as uutl


class SessionError(Exception):
    pass


class Session(object):
    @staticmethod
    def send_rack_geo():
        geo = [pm.PyNode("rackTop")]
        props.send(geo)

    @staticmethod
    def send_holder_geo():
        geo = pm.ls("holders|*|holderTrans|lowResGeo")
        props.send(geo)

    @staticmethod
    def send_handle_geo():
        geo = pm.ls("holes|*|holeTrans|wipe_loc|handle")
        props.send(geo)

    @staticmethod
    def send_pot_geo():
        geo = pm.ls("holes|*|holeTrans|dip_loc|pot")
        props.send(geo)

    @staticmethod
    def send_board_geo():
        geo = pm.PyNode("canvas")
        props.send(geo)

    @staticmethod
    def insert_external_dependencies(subprograms, src_filename):
        """
        Write lines into a program to tell it to include the ghiven subprograms.
        """
        print "Writing Externals", subprograms
        func = os.path.splitext(os.path.basename(src_filename))[0]
        func = "DEF {}".format(func)
        ext_lines = ["EXT {}()".format(s) for s in subprograms]
        search = True
        for line in fileinput.FileInput(src_filename, inplace=1):
            print line,
            if search and line.startswith(func):
                search = False
                for ext in ext_lines:
                    print ext

    @staticmethod
    def save_program(directory, program_name):
        src = os.path.join(directory, "src")
        uutl.mkdir_p(src)
        src_filename = robo.write_program(src, program_name)
        print "Wrote src: {}".format(program_name)
        return src_filename

    @staticmethod
    def save_station(directory, program_name):
        rdk = os.path.join(directory, "rdk")
        uutl.mkdir_p(rdk)
        rdk_fn = robo.write_station(rdk, program_name)
        print "Wrote rdk: {}".format(program_name)
        return rdk_fn

    @staticmethod
    def choose_session_dir():
        export_dir = os.path.join(pm.workspace.getPath(), "export")
        entries = pm.fileDialog2(
            caption="Choose directory", okCaption="Save", dialogStyle=2, fileMode=3, dir=export_dir
        )
        if not entries:
            pm.displayWarning("Nothing Selected")
            return

        timestamp = datetime.datetime.now().strftime("%y%m%d_%H%M")
        directory = os.path.join(entries[0], timestamp)
        uutl.mkdir_p(directory)
        return directory

    @staticmethod
    def orchestrate(directory, programs):
        """
        Write a program to act as orchestrator for several othyer programs.

        Writes main.src
        which includes a header and a list of function calls:
        prg1()
        prg2()
        prg3()


        """
        uutl.mkdir_p(directory)
        orchestrator_file = os.path.join(directory, "src", "main.src")
        with open(orchestrator_file, "w") as ofile:
            ofile.write("&ACCESS RVP\n")
            ofile.write("&REL 1\n")
            ofile.write("&COMMENT Generated by Uprising Robot Tools\n")
            ofile.write("&PARAM TEMPLATE = C:\\KRC\Roboter\\Template\\vorgabe\n")
            ofile.write("&PARAM EDITMASK = *\n")
            ofile.write("DEF pxMain ( )\n")
            for program in programs:
                ofile.write("{}( )\n".format(program))
            ofile.write("END\n")
        print "Wrote orchestrator file: {}".format(orchestrator_file)

    @staticmethod
    def json_report(directory, name, data):
        uutl.mkdir_p(directory)
        json_file = os.path.join(directory, "{}.json".format(name))
        with open(json_file, "w") as outfile:
            json.dump(data, outfile, indent=4)

    @staticmethod
    def write_maya_scene(directory, name):
        new_name = os.path.join(directory, "{}.ma".format(name))
        orig_sn = pm.sceneName()
        pm.saveAs(new_name)
        pm.renameFile(orig_sn)
