import fileinput
import os

from uprising import props
from uprising import robo
import datetime
import json
import pymel.core as pm
from uprising import utils


class SessionError(Exception):
    pass


class Session(object):
    @staticmethod
    def send_rack_geo():
        geo = [pm.PyNode("rackTop")]
        props.send(geo)

    @staticmethod
    def send_holder_geo():
        geo = pm.ls("holders|*|holderTrans|lowResGeo")
        props.send(geo)

    @staticmethod
    def send_handle_geo():
        geo = pm.ls("holes|*|holeTrans|wipe_loc|handle")
        geo += pm.ls("holes|*|holeTrans|wipe_loc|comb")
        props.send(geo)
    


    @staticmethod
    def send_pot_geo():
        geo = pm.ls("holes|*|holeTrans|dip_loc|pot")
        props.send(geo)

    @staticmethod
    def send_board_geo():
        geo = pm.PyNode("canvas")
        props.send(geo)

    @staticmethod
    def insert_external_dependencies(subprograms, src_filename):
        """
        Write lines into a program to tell it to include the ghiven subprograms.
        """
        print("Writing Externals", subprograms)
        func = os.path.splitext(os.path.basename(src_filename))[0]
        func = "DEF {}".format(func)
        ext_lines = ["EXT {}()".format(s) for s in subprograms]
        search = True
        for line in fileinput.FileInput(src_filename, inplace=1):
            print(line, end=' ')
            if search and line.startswith(func):
                search = False
                for ext in ext_lines:
                    print(ext)

    @staticmethod
    def save_program(directory, program_name):
        src = os.path.join(directory, "src")
        utils.mkdir_p(src)
        src_filename = robo.write_program(src, program_name)
        print("Wrote src: {}".format(program_name))
        return src_filename

    @staticmethod
    def save_station(directory, program_name):
        rdk = os.path.join(directory, "rdk")
        utils.mkdir_p(rdk)
        rdk_fn = robo.write_station(rdk, program_name)
        print("Wrote rdk: {}".format(program_name))
        return rdk_fn

    @staticmethod
    def choose_session_dir(suffix=None):
        export_dir = os.path.join(pm.workspace.getPath(), "export")
        entries = pm.fileDialog2(
            caption="Choose directory", okCaption="Save", dialogStyle=2, fileMode=3, dir=export_dir
        )
        if not entries:
            pm.displayWarning("Nothing Selected")
            return

        timestamp = datetime.datetime.now().strftime("%y%m%d_%H%M")
        directory = os.path.join(entries[0], timestamp)
        if suffix:
            directory = "{}_{}".format(directory, suffix)
        utils.mkdir_p(directory)
        return directory

    @staticmethod
    def orchestrate(directory, programs):
        """
        Write a program to act as orchestrator for several other programs.

        Writes main.src
        which includes a header and a list of function calls:
        prg1()
        prg2()
        prg3()


        """
        utils.mkdir_p(directory)
        orchestrator_file = os.path.join(directory, "src", "main.src")
        with open(orchestrator_file, "w") as ofile:
            ofile.write("&ACCESS RVP\n")
            ofile.write("&REL 1\n")
            ofile.write("&COMMENT Generated by Uprising Robot Tools\n")
            ofile.write("&PARAM TEMPLATE = C:\\KRC\Roboter\\Template\\vorgabe\n")
            ofile.write("&PARAM EDITMASK = *\n")
            ofile.write("DEF pxMain ( )\n")
            for program in programs:
                ofile.write("{}( )\n".format(program))
            ofile.write("END\n")
        print("Wrote orchestrator file: {}".format(orchestrator_file))

    @staticmethod
    def json_report(directory, name, data):
        utils.mkdir_p(directory)
        json_file = os.path.join(directory, "{}.json".format(name))
        with open(json_file, "w") as outfile:
            json.dump(data, outfile, indent=4)

    @staticmethod
    def write_maya_scene(directory, name):
        new_name = os.path.join(directory, "{}.ma".format(name))
        orig_sn = pm.sceneName()
        pm.saveAs(new_name)
        pm.renameFile(orig_sn)

    @staticmethod
    def write_text(directory, name, data):
        utils.mkdir_p(directory)
        text_file = os.path.join(directory, name)
        with open(text_file, "w") as outfile:
            outfile.write(data)

    @staticmethod
    def write_snapshot(directory, name):
        filename = os.path.join(directory, name)
        frame = int(pm.currentTime(q=True))


        editor = pm.playblast(activeEditor=True)
        pm.modelEditor(editor, e=True, camera="cameraShape1")

        with utils.at_value(pm.PyNode("cameraShape1").attr("overscan"), 0.460):
            pm.playblast(
                startTime=frame,
                endTime=frame,
                format="image",
                filename=filename,
                sequenceTime=0,
                clearCache=True,
                viewer=False,
                showOrnaments=False,
                offScreen=True,
                framePadding=4,
                percent=100,
                compression="png",
                quality=100,
                widthHeight=(1024, 1024))

