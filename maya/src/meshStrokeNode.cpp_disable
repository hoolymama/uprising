
#include <maya/MIOStream.h>
#include <math.h>
#include <algorithm>
#include <map>

#include <maya/MFnTypedAttribute.h>
#include <maya/MFnNumericAttribute.h>
#include <maya/MFnEnumAttribute.h>

#include <maya/MFnNurbsCurveData.h>

#include "meshStrokeNode.h"
#include "stroke.h"
#include "strokeRotationSpec.h"
#include "strokeRepeatSpec.h"

#include <jMayaIds.h>
#include "errorMacros.h"

const double rad_to_deg = (180 / 3.1415927);

MObject meshStrokeNode::aMesh;
MObject meshStrokeNode::aBrushRampScope;

MTypeId meshStrokeNode::id(k_meshStrokeNode);

meshStrokeNode::meshStrokeNode() {}

meshStrokeNode::~meshStrokeNode() {}

void *meshStrokeNode::creator()
{
    return new meshStrokeNode();
}

const double epsilon = 0.0001;

MStatus meshStrokeNode::initialize()
{
    MStatus st;

 
    MFnTypedAttribute tAttr;
    MFnEnumAttribute eAttr;
 

    MMatrix identity;
    identity.setToIdentity();

    inheritAttributesFrom("strokeNode");

    aMesh = tAttr.create("mesh", "msh", MFnData::kMesh);
    tAttr.setReadable(false);
    addAttribute(aMesh);
 
    aBrushRampScope = eAttr.create("brushRampScope", "brsc",
        StrokeRotationSpec::kStroke);
    eAttr.addField("stroke", StrokeRotationSpec::kStroke);
    eAttr.addField("travelStroke", StrokeRotationSpec::kTravelStroke);
    eAttr.addField("curve", StrokeRotationSpec::kCurve);
    eAttr.setKeyable(true);
    eAttr.setHidden(false);
    st = addAttribute(aBrushRampScope);
    mser;

    st = attributeAffects(aMesh, aOutput);
    st = attributeAffects(aBrushRampScope, aOutput);

    return (MS::kSuccess);
}

double clamp(double n, double lower = 0.0, double upper = 1.0)
{
    return std::max(lower, std::min(n, upper));
}

void clampSubCurveValues(double curveLen, double &subcurveMin, double &subcurveMax)
{
    subcurveMin = clamp(subcurveMin, 0.0, curveLen);
    subcurveMax = clamp(subcurveMax, subcurveMin, curveLen);
}

double randomize(double n, double factor)
{
    return n + (n * factor * 2.0 * (drand48() - 0.5));
}

double calculateEndDist(double startDist, double strokeLength, double randomLengthFactor,
                        double subcurveMax, double clip = 0.1)
{
    double length = randomize(strokeLength, randomLengthFactor);
    double maxlen = (strokeLength * 2) - clip;
    length = clamp(length, clip, maxlen);
    return fmin((startDist + length), subcurveMax);
}
double calculateStartDist(double startDist, double endDist, double overlap,
                          double randomOverlapFactor, double clip = 0.1)
{
    double thisOverlap = randomize(overlap, randomOverlapFactor);
    double result = endDist - thisOverlap;
    return fmax(result, (startDist + clip));
}

unsigned int meshStrokeNode::getStrokeBoundaries(
    MDataBlock &data,
    MVectorArray &result) const
{

    /*
      generate an array of start and end param for strokes
    */

    MStatus st = MS::kSuccess;

    MDataHandle hCurve = data.inputValue(aCurve, &st);
    msert;
    MObject dCurve = data.inputValue(aCurve).asNurbsCurveTransformed();
    double countFactor = data.inputValue(aStrokeCountFactor).asDouble();
    int seed = data.inputValue(aSeed).asInt();
    srand48(seed);

    double strokeLength = data.inputValue(aStrokeLength).asDouble();
    double randomLengthFactor = data.inputValue(aRandomLengthFactor).asDouble();
    double randomOverlapFactor = data.inputValue(aRandomOverlapFactor).asDouble();
    double overlap = data.inputValue(aOverlap).asDouble();

    MDataHandle hSubcurve = data.inputValue(aSubcurve);
    double subcurveMin = hSubcurve.child(aSubcurveMin).asDouble();
    double subcurveMax = hSubcurve.child(aSubcurveMax).asDouble();
    SubcurveMethod scMethod = SubcurveMethod(data.inputValue(aSubcurveMethod).asShort());

    MFnNurbsCurve curveFn(dCurve, &st);
    if (st.error())
    {
        return 0;
    }
    double curveLen = curveFn.length(epsilon);

    if (scMethod == meshStrokeNode::kBookends)
    {
        subcurveMax = curveLen - subcurveMax;
    }
    clampSubCurveValues(curveLen, subcurveMin, subcurveMax);

    randomLengthFactor = clamp(randomLengthFactor);
    randomOverlapFactor = clamp(randomOverlapFactor);

    double startDist = subcurveMin;
    double endDist;

    do
    {
        endDist = calculateEndDist(startDist, strokeLength, randomLengthFactor, subcurveMax);
        if (drand48() < countFactor)
        {
            result.append(MVector(startDist, endDist));
        }
        if (endDist >= subcurveMax)
        {
            break;
        }
        startDist = calculateStartDist(startDist, endDist, overlap, randomOverlapFactor);
        if (startDist >= subcurveMax)
        {
            break;
        }
    } while (true);

    return result.length();
}

MStatus meshStrokeNode::generateStrokeGeometry(
    MDataBlock &data,
    std::vector<Stroke> *pStrokes, 
    double &coilRadians) const
{

    MStatus st;

    if (!data.inputValue(aActive).asBool())
    {
        return MS::kSuccess;
    }

    // MVectorArray boundaries;
    // if (!getStrokeBoundaries(data, boundaries))
    // {
    //     return MS::kSuccess;
    // }


    MDataHandle hMesh = data.inputValue(aMesh, &st);
    msert;
    MObject inMesh = hMesh.asMeshTransformed();
    MFnMesh mFnIn(inMesh, &st);
    msert;

 
    double curveLength = curveFn.length(epsilon);
    double pointDensity = data.inputValue(aPointDensity).asDouble();
    if (pointDensity < 0.001)
    {
        pointDensity = 0.001;
    }
    int minimumPoints = data.inputValue(aMinimumPoints).asInt();
    double entryLength = data.inputValue(aEntryLength).asDouble();
    double exitLength = data.inputValue(aExitLength).asDouble();
    bool localContact = data.inputValue(aLocalContact).asBool();

    Stroke::TransitionBlendMethod transitionBlendMethod = Stroke::TransitionBlendMethod(
        data.inputValue(aTransitionBlendMethod).asShort());

    Stroke::DirectionMethod strokeDirection = Stroke::DirectionMethod(data.inputValue(aStrokeDirection).asShort());

    double pivotParam = data.inputValue(aPivotFraction).asDouble();

    double paintFlow = 1.0 // data.inputValue(aPaintFlowFactor).asDouble();

    StrokeRotationSpec rotSpec;
    rotSpec.tiltRampAtt = strokeNode::aBrushTiltRamp;
    rotSpec.bankRampAtt = strokeNode::aBrushBankRamp;
    rotSpec.twistRampAtt = strokeNode::aBrushTwistRamp;

    // MRampAttribute contactRampAttr(thisMObject(), aContactRamp, &st);
    // msert;

    // int contactRampResolution = data.inputValue(aContactRampResolution).asInt();

    MDataHandle hRangeHandle = data.inputValue(aBrushTiltRange);
    rotSpec.tiltRampMin = hRangeHandle.child(aBrushTiltRangeMin).asAngle().asRadians();
    rotSpec.tiltRampMax = hRangeHandle.child(aBrushTiltRangeMax).asAngle().asRadians();

    hRangeHandle = data.inputValue(aBrushBankRange);
    rotSpec.bankRampMin = hRangeHandle.child(aBrushBankRangeMin).asAngle().asRadians();
    rotSpec.bankRampMax = hRangeHandle.child(aBrushBankRangeMax).asAngle().asRadians();

    hRangeHandle = data.inputValue(aBrushTwistRange);
    rotSpec.twistRampMin = hRangeHandle.child(aBrushTwistRangeMin).asAngle().asRadians();
    rotSpec.twistRampMax = hRangeHandle.child(aBrushTwistRangeMax).asAngle().asRadians();

    rotSpec.rampScope = StrokeRotationSpec::Scope(data.inputValue(aBrushRampScope).asShort());
    rotSpec.followStroke = data.inputValue(aBrushFollowStroke).asBool();

    StrokeRepeatSpec repeatSpec;
    repeatSpec.repeats = data.inputValue(aRepeats).asShort();
    repeatSpec.offset = data.inputValue(aRepeatOffset).asDouble();
    repeatSpec.mirror = data.inputValue(aRepeatMirror).asBool();
    repeatSpec.oscillate = data.inputValue(aRepeatOscillate).asBool();
    repeatSpec.fan = data.inputValue(aRepeatFan).asAngle().asRadians();

    repeatSpec.seed = data.inputValue(aRepeatSeed).asInt();
    repeatSpec.probability = data.inputValue(aRepeatProbability).asDouble();

    repeatSpec.angleOffset = data.inputValue(aRepeatRandomAngleOffset).asAngle().asRadians();
    repeatSpec.normalOffset = data.inputValue(aRepeatRandomNormalOffset).asDouble();
    repeatSpec.tangentOffset = data.inputValue(aRepeatRandomTangentOffset).asDouble();

    short brushId = data.inputValue(aBrushId).asShort();
    short paintId = data.inputValue(aPaintId).asShort();
    int layerId = data.inputValue(aLayerId).asInt();

    //////////////////////////
    MDoubleArray contacts;
    if (contactRampResolution < 2)
    {
        contactRampResolution = 2;
    }
    float gap = 1.0f / float(contactRampResolution - 1);

    for (int i = 0; i < contactRampResolution; ++i)
    {
        float sample = float(i) * gap;
        float res;
        contactRampAttr.getValueAtPosition(sample, res, &st);
        mser;
        // cerr <<endl sample << ", ";
        /* We want the ramp to visually agree with the motion of the brush
        1.0 on the ramp is high - so 0 is full contact. Therefore, reverse
        the value.
        */
        contacts.append(double(1.0 - res));
    }
    // cerr << endl << "contacts" << contacts << endl;
    //////////////////////////

    MObject thisObj = thisMObject();
    for (int strokeId = 0; strokeId < boundaries.length(); ++strokeId)
    {
        const double &startDist = boundaries[strokeId].x;
        const double &endDist = boundaries[strokeId].y;

        unsigned strokeGroupSize = Stroke::create(
            thisObj,
            dCurve,
            contacts,
            localContact,
            curveLength,
            startDist,
            endDist,
            entryLength,
            exitLength,
            transitionBlendMethod,
            pointDensity,
            minimumPoints,
            rotSpec,
            repeatSpec,
            strokeDirection,
            pivotParam,
            paintFlow,
            strokeId,
            brushId,
            paintId,
            layerId,
            brushId,
            pStrokes);
    }

    return MS::kSuccess;
}

void meshStrokeNode::postConstructor()
{
    setExistWithoutInConnections(false);
    setExistWithoutOutConnections(true);
}
