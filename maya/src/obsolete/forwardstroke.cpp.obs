
#include <maya/MFnNurbsCurve.h>
#include <maya/MTransformationMatrix.h>
#include <maya/MQuaternion.h>
#include <stroke.h>
#include <forwardstroke.h>
#include <backstroke.h>

#include <attrUtils.h>
#include "errorMacros.h"

#include "mayaMath.h"

const double epsilon = 0.0001;

ForwardStroke::ForwardStroke()	{ }

ForwardStroke::~ForwardStroke() {}


// void ForwardStroke::getTravelStrokeFractions(MDoubleArray &result) const {
// 	std::vector<Target>::const_iterator citer = m_targets.begin();
// 	citer++;
// 	for (; std::next(citer) != m_targets.end(); citer++) {
// 		result.append(citer->strokeFraction());
// 	}
// }

void ForwardStroke::appendTargets(const MVector &planeNormal,
                                  MMatrixArray &result) const {
	std::vector<Target>::const_iterator citer;
	for (citer = m_targets.begin() ; citer != m_targets.end(); citer++) {
		result.append(citer->matrix(planeNormal));
	}
}

void ForwardStroke::appendTangents(MVectorArray &result) const {
	std::vector<Target>::const_iterator citer;
	for (citer = m_targets.begin() ; citer != m_targets.end(); citer++) {
		result.append(citer->tangent());
	}
}

void ForwardStroke::appendPoints(MVectorArray &result) const {
	std::vector<Target>::const_iterator citer;
	for (citer = m_targets.begin() ; citer != m_targets.end(); citer++) {
		result.append(MVector(citer->curvePoint()));
	}
}




// void Stroke::setHeights(const MObject &profileRampAttr) {

// }

// unsigned Stroke::length() const {
// 	return m_targets.size();
// }

// double Stroke::arcLength() const {
// 	return m_arcLength;
// }


// void Stroke::appendTargets(MMatrixArray &result) const {
// 	std::vector<Target>::const_iterator citer;
// 	for (citer = m_targets.begin() ; citer != m_targets.end(); citer++) {
// 		result.append(citer->matrix());
// 	}
// }

// void Stroke::appendTangents(MVectorArray &result) const {
// 	std::vector<Target>::const_iterator citer;
// 	for (citer = m_targets.begin() ; citer != m_targets.end(); citer++) {
// 		result.append(citer->tangent());
// 	}
// }
// void Stroke::appendPoints(MVectorArray &result) const {
// 	std::vector<Target>::const_iterator citer;
// 	for (citer = m_targets.begin() ; citer != m_targets.end(); citer++) {
// 		result.append(MVector(citer->curvePoint()));
// 	}
// }



/*
The two points that describe entry and exit at the boundaries of the stroke
*/

// MStatus calcBoundaryPositions(const MPoint &curvePoint, const MVector &tangent,
//                               const MVector &planeNormal,
//                               const Brush &brush, MVectorArray &result) {
// 	result = MVectorArray(2, MVector::zero);
// 	result[0] = curvePoint + ((tangent * brush.liftLength) + (planeNormal *
// 	                          brush.liftHeight));
// 	result[1] = curvePoint - (tangent * brush.liftBias);
// 	return MS::kSuccess;
// }

// MStatus calcBrushMatrixStroke(const MVector &position, const MVector &tangent,
//                               const MVector &planeNormal,
//                               const MVector &brushRotate, MMatrix &result,
//                               bool isBackstroke) {

// 	MMatrix mat =  mayaMath::matFromAim(position, tangent, planeNormal, mayaMath::yAxis ,
// 	                                    mayaMath::zAxisNeg);

// 	MTransformationMatrix tmat = MTransformationMatrix::identity;
// 	double3 rot;
// 	rot[0] = isBackstroke ? -brushRotate.x : brushRotate.x;
// 	rot[1] = brushRotate.y;
// 	rot[2] = brushRotate.z;
// 	tmat.setRotation(rot, MTransformationMatrix::kZYX);
// 	result =  tmat.asMatrix() * mat;
// 	return MS::kSuccess;
// }


// MStatus calcBrushMatrixWorld(const MVector &position,
//                              const MVector &tangent,
//                              const MVector &planeNormal,
//                              const MVector &brushRotate,
//                              MMatrix &result,
//                              bool isBackstroke) {





// 	MMatrix mat =  mayaMath::matFromAim(MVector::zero, MVector::xNegAxis, MVector::zAxis,
// 	                                    mayaMath::yAxis ,
// 	                                    mayaMath::zAxisNeg);


// 	// tilt it along the direction of travel
// 	MVector side(planeNormal ^ tangent);

// 	double tilt = isBackstroke ? -brushRotate.x : brushRotate.x;
// 	double bank = brushRotate.y;
// 	double twist = brushRotate.z;

// 	MMatrix twistMat = MQuaternion(twist, planeNormal).asMatrix();
// 	MMatrix bankMat = MQuaternion(bank, tangent).asMatrix();
// 	MMatrix tiltMat = MQuaternion(tilt, side).asMatrix();

// 	result = mat * twistMat * bankMat * tiltMat;
// 	result[3][0] = position.x;
// 	result[3][1] = position.y;
// 	result[3][2] = position.z;


// 	return MS::kSuccess;
// }





// MStatus calcBrushMatrix(const MVector &position, const MVector &tangent,
//                         const MVector &planeNormal,
//                         const MVector &brushRotate, MMatrix &result,
//                         bool follow, bool isBackstroke = false) {

// 	if (follow) {
// 		return calcBrushMatrixStroke(position, tangent, planeNormal, brushRotate,
// 		                             result, isBackstroke);
// 	}


// 	return calcBrushMatrixWorld(position , tangent, planeNormal, brushRotate,
// 	                            result, isBackstroke);
// }


// MVector Stroke::getLiftStartTarget(const MObject &curveObject) {
// 	MFnNurbsCurve curveFn(curveObject);
// 	liftOffset  = m_liftBias - m_liftLength;
// 	startLiftDist = m_startDist - liftOffset;
// 	if (startLiftDist < 0) {

// 	}

// }


// MStatus Stroke::generateTargets(const MObject &curveObject) {
// 	MFnNurbsCurve curveFn(curveObject);
// 	double curveLength = curveFn.length(epsilon);


// 	liftOffset  = m_liftBias - m_liftLength;
// 	startLiftDist = m_startDist - liftOffset;
// 	startBiasDist = m_startDist + m_liftBias;
// 	if (startLiftDist < 0) {
// 		// find point back along tangent

// 	}
// 	else {
// 		// find point on curve
// 	}



// 	endLiftDist = m_endDist + liftOffset;
// 	endBiasDist = m_endDist - m_liftBias;


// 	m_curvePoints.append(getStartLiftPoint(MFnNurbsCurve & curveObject, )

// 	if (startLiftDist < 0) {

// }

// {
// double absCurveDist = fabs(endDist - startDist);

// unsigned numPoints = unsigned(density * absCurveDist);

// if (backstroke) {
// 	double tmp = startDist;
// 	startDist = endDist;
// 	endDist = tmp;
// }

// double curveSpan = endDist - startDist;

// MFnNurbsCurve curveFn(curveObject, &st);


// if (numPoints < 2) { numPoints = 2; }
// double recip = 1.0 / (numPoints - 1);

// // get an array of params
// MDoubleArray params(numPoints);
// for (unsigned i = 0; i < numPoints; i++) {
// 	double fraction =  (double(i) * recip);
// 	double dist = startDist + (fraction * curveSpan);
// 	double param = curveFn.findParamFromLength(dist, &st); mser;
// 	params.set(param, i);
// }

// MPoint lastPoint;

// MPoint curvePoint;
// MMatrix brushMatrix;


// for (unsigned i = 0; i < numPoints; i++) {

// 	st = curveFn.getPointAtParam(params[i], curvePoint, MSpace::kObject);

// 	// get the flat tangent
// 	MVector curveTangent = curveFn.tangent(params[i]).normal();

// 	MVector tangent = (planeNormal ^ (curveTangent ^ planeNormal)).normal();
// 	if (backstroke) {
// 		tangent = -tangent;
// 	}

// 	if (i == 0) {

// 		MVectorArray boundaryPositions;
// 		// MVector boundaryTangent = backstroke ? tangent : -tangent;
// 		st = calcBoundaryPositions(curvePoint, -tangent, planeNormal, brush ,
// 		                           boundaryPositions);
// 		mser;



// 		st = calcBrushMatrix(boundaryPositions[0] , curveTangent, planeNormal, brushRotate,
// 		                     brushMatrix, follow, backstroke);



// 		m_targets.append(brushMatrix);
// 		st = calcBrushMatrix(boundaryPositions[1], curveTangent, planeNormal, brushRotate,
// 		                     brushMatrix, follow, backstroke);

// 		m_targets.append(brushMatrix);
// 		m_tangents.append(tangent);
// 		m_tangents.append(tangent);

// 	}
// 	else if (i == (numPoints - 1))  {
// 		MVectorArray boundaryPositions;
// 		// MVector boundaryTangent = backstroke ? -tangent : tangent;
// 		st = calcBoundaryPositions(curvePoint, tangent, planeNormal, brush,
// 		                           boundaryPositions);
// 		mser;

// 		st = calcBrushMatrix(boundaryPositions[1], curveTangent, planeNormal, brushRotate,
// 		                     brushMatrix, follow, backstroke);
// 		m_targets.append(brushMatrix);

// 		st = calcBrushMatrix(boundaryPositions[0], curveTangent, planeNormal, brushRotate,
// 		                     brushMatrix, follow, backstroke);
// 		m_targets.append(brushMatrix);
// 		m_tangents.append(tangent);
// 		m_tangents.append(tangent);
// 	}
// 	else {
// 		st = calcBrushMatrix(curvePoint, curveTangent, planeNormal, brushRotate,  brushMatrix,
// 		                     follow,
// 		                     backstroke);
// 		m_targets.append(brushMatrix);
// 		m_tangents.append(tangent);
// 	}

// 	if (i != 0) {
// 		m_arcLength += lastPoint.distanceTo(curvePoint);
// 	}
// 	lastPoint = curvePoint;
// }

// For now, set pivot halfway along stroke.

// double dist = startDist + (pivotFraction * curveSpan );
// double param = curveFn.findParamFromLength(dist, &st); mser;
// st = curveFn.getPointAtParam(param, m_pivot, MSpace::kObject);
// }



// Stroke::Stroke(
//   const Stroke & mother,
//   double offset,
//   double advance,
//   bool reverse,
//   const MVector & planeNormal
// )	:
// m_curveId(mother.curveId()),
// m_targets(),
// m_tangents(),
// m_brush(mother.brush()),
// m_paint(mother.paint()),
// m_rotation(mother.rotation()),
// m_translation(mother.translation()),
// m_pivot(mother.pivot()),
// m_brushRotate(mother.brushRotate()),
// m_follow(mother.follow()),
// m_forceDip(false),
// m_arcLength(),
// m_approachDistStart(1),
// m_approachDistEnd(1),
// m_isBackstroke(false)
// {
// 	MStatus st;
// 	// m_arcLength = endDist - startDist;

// 	if (mother.isBackstroke()) {
// 		m_isBackstroke = !reverse;
// 	}
// 	else {
// 		m_isBackstroke = reverse;
// 	}


// 	unsigned numPoints = mother.targets().length();
// 	MPoint lastPoint;
// 	m_arcLength = 0.0;
// 	MPoint thisPoint;
// 	MMatrix brushMatrix;

// 	for (int i = 0; i < numPoints; ++i)
// 	{
// 		int j = reverse ? numPoints - (i + 1) : i;


// 		const MMatrix &mm = mother.targets()[j];

// 		MVector curveTangent = mother.isBackstroke() ?  -mother.tangents()[j] :
// 		                       mother.tangents()[j];
// 		// const MVector &tangent = mother.tangents()[j];
// 		MVector tangent = reverse ? -mother.tangents()[j]  : mother.tangents()[j];


// 		MVector advance_vec = MVector::zero;
// 		if (i < 2) {
// 			advance_vec = tangent * advance;
// 			// if (m_isBackstroke) {
// 			// 	advance_vec = advance_vec * -1;
// 			// }
// 		}


// 		MVector offsetVec = ((curveTangent ^ planeNormal) * offset) - advance_vec;
// 		thisPoint = MPoint(mm[3][0], mm[3][1], mm[3][2]) + offsetVec;

// 		st = calcBrushMatrix(thisPoint, curveTangent, planeNormal, m_brushRotate,
// 		                     brushMatrix, m_follow, m_isBackstroke);

// 		m_targets.append(brushMatrix);



// 		// if (m_isBackstroke) {
// 		m_tangents.append(tangent);
// 		// }
// 		// else {
// 		// 	m_tangents.append(tangent);
// 		// }


// 		if (i > 1 && i < numPoints - 1) {
// 			m_arcLength += lastPoint.distanceTo(thisPoint);
// 		}
// 		lastPoint = thisPoint;
// 	}
// }




// const MMatrixArray & Stroke::targets() const {
// 	return m_targets;
// }
// const MVectorArray & Stroke::tangents() const {
// 	return m_tangents;
// }

// const Brush & Stroke::brush() const {
// 	return m_brush;
// }
// const Paint & Stroke::paint() const {
// 	return m_paint;
// }

// const MPoint & Stroke::pivot() const {
// 	return m_pivot;
// }

// const MVector & Stroke::brushRotate() const {
// 	return m_brushRotate;
// }

// double Stroke::arcLength() const {
// 	return m_arcLength;
// }
// double Stroke::rotation() const {
// 	return m_rotation;
// }
// double Stroke::translation() const {
// 	return m_translation;
// }

// bool Stroke::follow() const {
// 	return m_follow;
// }

// bool  Stroke::forceDip() const {
// 	return m_forceDip;
// }

// bool Stroke::isBackstroke() const {
// 	return m_isBackstroke;
// }

// unsigned  Stroke::curveId() const {
// 	return m_curveId;
// }

// void Stroke::setApproach(double start, double end)  {
// 	m_approachDistStart = start;
// 	m_approachDistEnd = end;
// }

// double Stroke::approachStart() const {
// 	return m_approachDistStart;
// }

// double Stroke::approachEnd() const {
// 	return m_approachDistEnd;
// }

// void Stroke::getPivotUVs(const MMatrix & inversePlaneMatrix, float & u, float & v) const {
// 	MPoint p = ((m_pivot * inversePlaneMatrix) * 0.5) + MVector(0.5, 0.5, 0.0);
// 	u = p.x;
// 	v = p.y;
// }


// bool Stroke::overlapsPlane(const MMatrix & inversePlaneMatrix) const {
// 	unsigned len = m_targets.length();
// 	for (int i = 0; i < len; ++i)
// 	{
// 		MPoint p = MPoint(m_targets[i][3][0], m_targets[i][3][1],
// 		                  m_targets[i][3][2]) * inversePlaneMatrix;
// 		if (p.x > -1 && p.x < 1 && p.y > -1 && p.y < 1) {
// 			return true;
// 		}
// 	}
// 	return false;
// }

// void Stroke::rotate(float rotation, const MVector & axis) {
// 	double  rotateAmount = rotation * m_rotation;
// 	MMatrix mat = MQuaternion(rotateAmount, axis).asMatrix();
// 	unsigned len = m_targets.length();
// 	MMatrix pivotMat;
// 	pivotMat[3][0] = m_pivot.x;
// 	pivotMat[3][1] = m_pivot.y;
// 	pivotMat[3][2] = m_pivot.z;

// 	for (int i = 0; i < len; ++i)
// 	{
// 		m_targets[i] = ((m_targets[i] * pivotMat.inverse()) * mat) * pivotMat ;
// 	}
// }


// void Stroke::translate(const MFloatVector & translation, const MVector & planeNormal) {
// 	// rotation to planNormal.
// 	MMatrix mat = MQuaternion(MVector::zAxis, planeNormal).asMatrix();
// 	MVector trans = (MVector(translation) * m_translation) * mat;
// 	MMatrix transMat;
// 	transMat[3][0] = trans.x;
// 	transMat[3][1] = trans.y;
// 	transMat[3][2] = trans.z;

// 	unsigned len = m_targets.length();
// 	for (int i = 0; i < len; ++i)
// 	{
// 		m_targets[i]  = m_targets[i] + transMat ;
// 	}
// }
